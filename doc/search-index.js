var searchIndex = {};
searchIndex['tensors'] = {"items":[[0,"","tensors",""],[0,"vec","",""],[1,"Vec","tensors::vec",""],[2,"TransVec","",""],[12,"T","","",0],[12,"H","","",0],[10,"from_vec","","",1],[10,"as_vec","","",1],[10,"as_vec","","",0],[10,"inc","","",1],[10,"len","","",1],[10,"as_ptr","","",1],[10,"as_mut_ptr","","",1],[10,"clone","","",1],[10,"add","","",1],[10,"mul","","",1],[10,"mul","","",1],[10,"mul","","",0],[0,"mat","tensors",""],[1,"Mat","tensors::mat",""],[10,"new","","",2],[10,"from_vec","","",2],[10,"zero","","",2],[10,"push","","",2],[10,"rows","","",2],[10,"cols","","",2],[10,"set_rows","","",2],[10,"set_cols","","",2],[10,"as_slice","","",2],[10,"as_mut_slice","","",2],[10,"rows","","",2],[10,"cols","","",2],[10,"as_ptr","","",2],[10,"as_mut_ptr","","",2],[10,"clone","","",2],[10,"eq","","",2],[10,"index","","",2],[10,"fmt","","",2],[10,"mul","","",2],[10,"mul","","",2],[15,"mat!","tensors",""]],"paths":[[2,"TransVec"],[1,"Vec"],[1,"Mat"]]};
searchIndex['blas'] = {"items":[[0,"","blas",""],[0,"vector","",""],[0,"ll","blas::vector",""],[13,"cblas_scopy","blas::vector::ll",""],[13,"cblas_dcopy","",""],[13,"cblas_ccopy","",""],[13,"cblas_zcopy","",""],[13,"cblas_saxpy","",""],[13,"cblas_daxpy","",""],[13,"cblas_caxpy","",""],[13,"cblas_zaxpy","",""],[13,"cblas_sscal","",""],[13,"cblas_dscal","",""],[13,"cblas_cscal","",""],[13,"cblas_zscal","",""],[13,"cblas_csscal","",""],[13,"cblas_zdscal","",""],[13,"cblas_sswap","",""],[13,"cblas_dswap","",""],[13,"cblas_cswap","",""],[13,"cblas_zswap","",""],[13,"cblas_sdsdot","",""],[13,"cblas_dsdot","",""],[13,"cblas_sdot","",""],[13,"cblas_ddot","",""],[13,"cblas_cdotu_sub","",""],[13,"cblas_zdotu_sub","",""],[13,"cblas_cdotc_sub","",""],[13,"cblas_zdotc_sub","",""],[13,"cblas_sasum","",""],[13,"cblas_dasum","",""],[13,"cblas_scasum","",""],[13,"cblas_dzasum","",""],[13,"cblas_snrm2","",""],[13,"cblas_dnrm2","",""],[13,"cblas_scnrm2","",""],[13,"cblas_dznrm2","",""],[13,"cblas_isamax","",""],[13,"cblas_idamax","",""],[13,"cblas_icamax","",""],[13,"cblas_izamax","",""],[13,"cblas_srot","",""],[13,"cblas_drot","",""],[13,"cblas_srotm","",""],[13,"cblas_drotm","",""],[13,"cblas_srotg","",""],[13,"cblas_drotg","",""],[13,"cblas_srotmg","",""],[13,"cblas_drotmg","",""],[0,"ops","blas::vector",""],[6,"Copy","blas::vector::ops",""],[9,"copy","","",0],[6,"Axpy","",""],[9,"axpy","","",1],[6,"Scal","",""],[9,"scal","","",2],[6,"Swap","",""],[9,"swap","","",3],[6,"Dot","",""],[9,"dot","","",4],[6,"Dotc","",""],[10,"dotc","","",5],[6,"Asum","",""],[9,"asum","","",6],[6,"Nrm2","",""],[9,"nrm2","","",7],[6,"Iamax","",""],[9,"iamax","","",8],[6,"Rot","",""],[9,"rot","","",9],[10,"copy","","",10],[10,"copy","","",11],[10,"axpy","","",10],[10,"axpy","","",11],[10,"scal","","",10],[10,"scal","","",11],[10,"swap","","",10],[10,"swap","","",11],[10,"dot","","",10],[10,"dot","","",11],[10,"dotc","","",10],[10,"dotc","","",11],[10,"asum","","",10],[10,"asum","","",11],[10,"nrm2","","",10],[10,"nrm2","","",11],[10,"iamax","","",10],[10,"iamax","","",11],[6,"Vector","blas::vector",""],[9,"inc","","",12],[9,"len","","",12],[9,"as_ptr","","",12],[9,"as_mut_ptr","","",12],[6,"VectorOperations","",""],[10,"into_vec","","",13],[10,"update","","",13],[10,"scale","","",13],[10,"dot","","",13],[10,"abs_sum","","",13],[10,"norm","","",13],[10,"max_index","","",13],[10,"inc","collections::vec","",14],[10,"len","","",14],[10,"as_ptr","","",14],[10,"as_mut_ptr","","",14],[0,"matrix_vector","blas",""],[0,"ll","blas::matrix_vector",""],[13,"cblas_sgemv","blas::matrix_vector::ll",""],[13,"cblas_dgemv","",""],[13,"cblas_cgemv","",""],[13,"cblas_zgemv","",""],[13,"cblas_ssymv","",""],[13,"cblas_dsymv","",""],[13,"cblas_csymv","",""],[13,"cblas_zsymv","",""],[13,"cblas_chemv","",""],[13,"cblas_zhemv","",""],[13,"cblas_strmv","",""],[13,"cblas_dtrmv","",""],[13,"cblas_ctrmv","",""],[13,"cblas_ztrmv","",""],[13,"cblas_strsv","",""],[13,"cblas_dtrsv","",""],[13,"cblas_ctrsv","",""],[13,"cblas_ztrsv","",""],[13,"cblas_sger","",""],[13,"cblas_dger","",""],[13,"cblas_cgeru","",""],[13,"cblas_zgeru","",""],[13,"cblas_cgerc","",""],[13,"cblas_zgerc","",""],[13,"cblas_cher","",""],[13,"cblas_zher","",""],[13,"cblas_ssyr","",""],[13,"cblas_dsyr","",""],[13,"cblas_cher2","",""],[13,"cblas_zher2","",""],[13,"cblas_ssyr2","",""],[13,"cblas_dsyr2","",""],[13,"cblas_sgbmv","",""],[13,"cblas_dgbmv","",""],[13,"cblas_cgbmv","",""],[13,"cblas_zgbmv","",""],[13,"cblas_chbmv","",""],[13,"cblas_zhbmv","",""],[13,"cblas_ssbmv","",""],[13,"cblas_dsbmv","",""],[13,"cblas_stbmv","",""],[13,"cblas_dtbmv","",""],[13,"cblas_ctbmv","",""],[13,"cblas_ztbmv","",""],[13,"cblas_stbsv","",""],[13,"cblas_dtbsv","",""],[13,"cblas_ctbsv","",""],[13,"cblas_ztbsv","",""],[13,"cblas_chpmv","",""],[13,"cblas_zhpmv","",""],[13,"cblas_sspmv","",""],[13,"cblas_dspmv","",""],[13,"cblas_stpmv","",""],[13,"cblas_dtpmv","",""],[13,"cblas_ctpmv","",""],[13,"cblas_ztpmv","",""],[13,"cblas_stpsv","",""],[13,"cblas_dtpsv","",""],[13,"cblas_ctpsv","",""],[13,"cblas_ztpsv","",""],[13,"cblas_chpr","",""],[13,"cblas_zhpr","",""],[13,"cblas_sspr","",""],[13,"cblas_dspr","",""],[13,"cblas_chpr2","",""],[13,"cblas_zhpr2","",""],[13,"cblas_sspr2","",""],[13,"cblas_dspr2","",""],[0,"ops","blas::matrix_vector",""],[6,"Gemv","blas::matrix_vector::ops",""],[9,"gemv","","",15],[6,"Symv","",""],[9,"symv","","",16],[6,"Hemv","",""],[9,"hemv","","",17],[6,"Ger","",""],[9,"ger","","",18],[6,"Gerc","",""],[10,"gerc","","",19],[6,"Her","",""],[9,"her","","",20],[6,"Syr","",""],[9,"syr","","",21],[6,"Syr2","",""],[9,"syr2","","",22],[6,"Her2","",""],[9,"her2","","",23],[6,"Gbmv","",""],[9,"gbmv","","",24],[6,"Sbmv","",""],[9,"sbmv","","",25],[6,"Hbmv","",""],[9,"hbmv","","",26],[6,"Tbmv","",""],[9,"tbmv","","",27],[6,"Tbsv","",""],[9,"tbsv","","",28],[6,"Spmv","",""],[9,"spmv","","",29],[6,"Hpmv","",""],[9,"hpmv","","",30],[6,"Tpmv","",""],[9,"tpmv","","",31],[6,"Tpsv","",""],[9,"tpsv","","",32],[6,"Hpr","",""],[9,"hpr","","",33],[6,"Spr","",""],[9,"spr","","",34],[6,"Spr2","",""],[9,"spr2","","",35],[6,"Hpr2","",""],[9,"hpr2","","",36],[10,"gemv","","",10],[10,"gemv","","",11],[10,"symv","","",10],[10,"symv","","",11],[10,"hemv","","",10],[10,"hemv","","",11],[10,"ger","","",10],[10,"ger","","",11],[10,"gerc","","",10],[10,"gerc","","",11],[10,"her2","","",10],[10,"her2","","",11],[10,"gbmv","","",10],[10,"gbmv","","",11],[10,"hbmv","","",10],[10,"hbmv","","",11],[10,"tbmv","","",10],[10,"tbmv","","",11],[10,"tbsv","","",10],[10,"tbsv","","",11],[10,"hpmv","","",10],[10,"hpmv","","",11],[10,"tpmv","","",10],[10,"tpmv","","",11],[10,"tpsv","","",10],[10,"tpsv","","",11],[10,"hpr2","","",10],[10,"hpr2","","",11],[0,"matrix","blas",""],[0,"ll","blas::matrix",""],[13,"cblas_sgemm","blas::matrix::ll",""],[13,"cblas_dgemm","",""],[13,"cblas_cgemm","",""],[13,"cblas_zgemm","",""],[13,"cblas_ssymm","",""],[13,"cblas_dsymm","",""],[13,"cblas_csymm","",""],[13,"cblas_zsymm","",""],[13,"cblas_chemm","",""],[13,"cblas_zhemm","",""],[13,"cblas_strmm","",""],[13,"cblas_dtrmm","",""],[13,"cblas_ctrmm","",""],[13,"cblas_ztrmm","",""],[13,"cblas_strsm","",""],[13,"cblas_dtrsm","",""],[13,"cblas_ctrsm","",""],[13,"cblas_ztrsm","",""],[13,"cblas_cherk","",""],[13,"cblas_zherk","",""],[13,"cblas_cher2k","",""],[13,"cblas_zher2k","",""],[13,"cblas_ssyrk","",""],[13,"cblas_dsyrk","",""],[13,"cblas_csyrk","",""],[13,"cblas_zsyrk","",""],[13,"cblas_ssyr2k","",""],[13,"cblas_dsyr2k","",""],[13,"cblas_csyr2k","",""],[13,"cblas_zsyr2k","",""],[0,"ops","blas::matrix",""],[6,"Gemm","blas::matrix::ops",""],[9,"gemm","","",37],[6,"Symm","",""],[9,"symm","","",38],[6,"Hemm","",""],[9,"hemm","","",39],[6,"Trmm","",""],[9,"trmm","","",40],[6,"Trsm","",""],[9,"trsm","","",41],[6,"Herk","",""],[9,"herk","","",42],[6,"Her2k","",""],[9,"her2k","","",43],[6,"Syrk","",""],[9,"syrk","","",44],[6,"Syr2k","",""],[9,"syr2k","","",45],[10,"gemm","","",10],[10,"gemm","","",11],[10,"symm","","",10],[10,"symm","","",11],[10,"hemm","","",10],[10,"hemm","","",11],[10,"trmm","","",10],[10,"trmm","","",11],[10,"trsm","","",10],[10,"trsm","","",11],[10,"syrk","","",10],[10,"syrk","","",11],[10,"syr2k","","",10],[10,"syr2k","","",11],[6,"Matrix","blas::matrix",""],[10,"lead_dim","","",46],[10,"order","","",46],[10,"transpose","","",46],[9,"rows","","",46],[9,"cols","","",46],[9,"as_ptr","","",46],[9,"as_mut_ptr","","",46],[6,"BandMatrix","",""],[9,"sub_diagonals","","",47],[9,"sup_diagonals","","",47],[0,"attribute","blas",""],[2,"Order","blas::attribute",""],[12,"RowMajor","","",48],[12,"ColMajor","","",48],[2,"Transpose","",""],[12,"NoTrans","","",49],[12,"Trans","","",49],[12,"ConjTrans","","",49],[2,"Symmetry","",""],[12,"Upper","","",50],[12,"Lower","","",50],[2,"Diagonal","",""],[12,"NonUnit","","",51],[12,"Unit","","",51],[2,"Side","",""],[12,"Left","","",52],[12,"Right","","",52],[0,"default","blas",""],[6,"Default","blas::default",""],[9,"one","","",53],[9,"zero","","",53],[10,"one","num::complex","",54],[10,"zero","","",54],[10,"one","","",54],[10,"zero","","",54],[0,"pointer","blas",""],[6,"CPtr","blas::pointer",""],[9,"as_c_ptr","","",55]],"paths":[[6,"Copy"],[6,"Axpy"],[6,"Scal"],[6,"Swap"],[6,"Dot"],[6,"Dotc"],[6,"Asum"],[6,"Nrm2"],[6,"Iamax"],[6,"Rot"],[4,"Complex32"],[4,"Complex64"],[6,"Vector"],[6,"VectorOperations"],[1,"Vec"],[6,"Gemv"],[6,"Symv"],[6,"Hemv"],[6,"Ger"],[6,"Gerc"],[6,"Her"],[6,"Syr"],[6,"Syr2"],[6,"Her2"],[6,"Gbmv"],[6,"Sbmv"],[6,"Hbmv"],[6,"Tbmv"],[6,"Tbsv"],[6,"Spmv"],[6,"Hpmv"],[6,"Tpmv"],[6,"Tpsv"],[6,"Hpr"],[6,"Spr"],[6,"Spr2"],[6,"Hpr2"],[6,"Gemm"],[6,"Symm"],[6,"Hemm"],[6,"Trmm"],[6,"Trsm"],[6,"Herk"],[6,"Her2k"],[6,"Syrk"],[6,"Syr2k"],[6,"Matrix"],[6,"BandMatrix"],[2,"Order"],[2,"Transpose"],[2,"Symmetry"],[2,"Diagonal"],[2,"Side"],[6,"Default"],[1,"Complex"],[6,"CPtr"]]};

searchIndex['lapack'] = {"items":[[0,"","lapack",""],[0,"matrix","",""],[6,"Matrix","lapack::matrix",""],[9,"rows","","",0],[9,"cols","","",0],[9,"as_ptr","","",0],[9,"as_mut_ptr","","",0],[6,"BandMatrix","",""],[9,"sub_diagonals","","",1],[9,"sup_diagonals","","",1],[6,"TridiagonalMatrix","",""],[9,"as_ptrs","","",2],[9,"as_mut_ptrs","","",2],[6,"SymmetricMatrix","",""],[9,"symmetry","","",3],[0,"linear_equations","lapack",""],[0,"ll","lapack::linear_equations",""],[13,"sgesv_","lapack::linear_equations::ll",""],[13,"dgesv_","",""],[13,"cgesv_","",""],[13,"zgesv_","",""],[13,"sgbsv_","",""],[13,"dgbsv_","",""],[13,"cgbsv_","",""],[13,"zgbsv_","",""],[13,"sgtsv_","",""],[13,"dgtsv_","",""],[13,"cgtsv_","",""],[13,"zgtsv_","",""],[13,"sposv_","",""],[13,"dposv_","",""],[13,"cposv_","",""],[13,"zposv_","",""],[13,"sppsv_","",""],[13,"dppsv_","",""],[13,"cppsv_","",""],[13,"zppsv_","",""],[13,"spbsv_","",""],[13,"dpbsv_","",""],[13,"cpbsv_","",""],[13,"zpbsv_","",""],[0,"ops","lapack::linear_equations",""],[6,"Gesv","lapack::linear_equations::ops",""],[9,"gesv","","",4],[6,"Gbsv","",""],[9,"gbsv","","",5],[6,"Gtsv","",""],[9,"gtsv","","",6],[6,"Posv","",""],[9,"posv","","",7],[6,"Ppsv","",""],[9,"ppsv","","",8],[6,"Pbsv","",""],[9,"pbsv","","",9],[10,"gesv","","",10],[10,"gesv","","",11],[10,"gbsv","","",10],[10,"gbsv","","",11],[10,"gtsv","","",10],[10,"gtsv","","",11],[10,"posv","","",10],[10,"posv","","",11],[10,"ppsv","","",10],[10,"ppsv","","",11],[10,"pbsv","","",10],[10,"pbsv","","",11]],"paths":[[6,"Matrix"],[6,"BandMatrix"],[6,"TridiagonalMatrix"],[6,"SymmetricMatrix"],[6,"Gesv"],[6,"Gbsv"],[6,"Gtsv"],[6,"Posv"],[6,"Ppsv"],[6,"Pbsv"],[4,"Complex32"],[4,"Complex64"]]};

searchIndex['num'] = {"items":[[0,"","num","Simple numerics."],[3,"zero","","Returns the additive identity, `0`."],[3,"one","","Returns the multiplicative identity, `1`."],[3,"abs","","Computes the absolute value."],[3,"abs_sub","","The positive difference of two numbers."],[3,"signum","","Returns the sign of the number."],[3,"pow","","Raises a value to the power of exp, using exponentiation by squaring."],[0,"bigint","","A Big integer (signed version: `BigInt`, unsigned version: `BigUint`)."],[1,"BigUint","num::bigint","A big unsigned integer type."],[1,"BigInt","","A big signed integer type."],[2,"Sign","","A Sign is a `BigInt`'s composing element."],[12,"Minus","","",0],[12,"NoSign","","",0],[12,"Plus","","",0],[0,"BigDigit","",""],[3,"from_doublebigdigit","num::bigint::BigDigit","Split one `DoubleBigDigit` into two `BigDigit`s."],[3,"to_doublebigdigit","","Join two `BigDigit`s into one `DoubleBigDigit`"],[18,"BITS","",""],[18,"BASE","",""],[4,"BigDigit","num::bigint","A `BigDigit` is a `BigUint`'s composing element."],[4,"DoubleBigDigit","","A `DoubleBigDigit` is the internal type used to do the computations.  Its\nsize is the double of the size of `BigDigit`."],[18,"ZERO_BIG_DIGIT","",""],[6,"ToBigUint","","A generic trait for converting a value to a `BigUint`."],[9,"to_biguint","","Converts the value of `self` to a `BigUint`.",1],[6,"ToBigInt","","A generic trait for converting a value to a `BigInt`."],[9,"to_bigint","","Converts the value of `self` to a `BigInt`.",2],[6,"RandBigInt","",""],[9,"gen_biguint","","Generate a random `BigUint` of the given bit size.",3],[9,"gen_bigint","","Generate a random BigInt of the given bit size.",3],[9,"gen_biguint_below","","Generate a random `BigUint` less than the given bound. Fails\nwhen the bound is zero.",3],[9,"gen_biguint_range","","Generate a random `BigUint` within the given range. The lower\nbound is inclusive; the upper bound is exclusive. Fails when\nthe upper bound is not greater than the lower bound.",3],[9,"gen_bigint_range","","Generate a random `BigInt` within the given range. The lower\nbound is inclusive; the upper bound is exclusive. Fails when\nthe upper bound is not greater than the lower bound.",3],[10,"decode","","",4],[10,"encode","","",4],[10,"clone","","",4],[10,"eq","","",4],[10,"partial_cmp","","",4],[10,"cmp","","",4],[10,"default","","",4],[10,"hash","","",4],[10,"fmt","","",4],[10,"from_str","","",4],[10,"bitand","","",4],[10,"bitor","","",4],[10,"bitxor","","",4],[10,"shl","","",4],[10,"shr","","",4],[10,"zero","","",4],[10,"is_zero","","",4],[10,"one","","",4],[10,"add","","",4],[10,"sub","","",4],[10,"mul","","",4],[10,"div","","",4],[10,"rem","","",4],[10,"neg","","",4],[10,"checked_add","","",4],[10,"checked_sub","","",4],[10,"checked_mul","","",4],[10,"checked_div","","",4],[10,"div_rem","","",4],[10,"div_floor","","",4],[10,"mod_floor","","",4],[10,"div_mod_floor","","",4],[10,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`.",4],[10,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",4],[10,"divides","","Deprecated, use `is_multiple_of` instead.",4],[10,"is_multiple_of","","Returns `true` if the number is a multiple of `other`.",4],[10,"is_even","","Returns `true` if the number is divisible by `2`.",4],[10,"is_odd","","Returns `true` if the number is not divisible by `2`.",4],[10,"to_i64","","",4],[10,"to_u64","","",4],[10,"from_i64","","",4],[10,"from_u64","","",4],[10,"to_biguint","","",5],[10,"to_biguint","","",4],[10,"from_str_radix","","Creates and initializes a `BigUint`.",4],[10,"new","","Creates and initializes a `BigUint`.",4],[10,"from_slice","","Creates and initializes a `BigUint`.",4],[10,"parse_bytes","","Creates and initializes a `BigUint`.",4],[10,"bits","","Determines the fewest bits necessary to express the `BigUint`.",4],[10,"decode","","",0],[10,"encode","","",0],[10,"fmt","","",0],[10,"clone","","",0],[10,"cmp","","",0],[10,"partial_cmp","","",0],[10,"lt","","",0],[10,"le","","",0],[10,"gt","","",0],[10,"ge","","",0],[10,"eq","","",0],[10,"ne","","",0],[10,"neg","","Negate Sign value.",0],[10,"decode","","",5],[10,"encode","","",5],[10,"clone","","",5],[10,"eq","","",5],[10,"partial_cmp","","",5],[10,"cmp","","",5],[10,"default","","",5],[10,"fmt","","",5],[10,"hash","","",5],[10,"from_str","","",5],[10,"shl","","",5],[10,"shr","","",5],[10,"zero","","",5],[10,"is_zero","","",5],[10,"one","","",5],[10,"abs","","",5],[10,"abs_sub","","",5],[10,"signum","","",5],[10,"is_positive","","",5],[10,"is_negative","","",5],[10,"add","","",5],[10,"sub","","",5],[10,"mul","","",5],[10,"div","","",5],[10,"rem","","",5],[10,"neg","","",5],[10,"checked_add","","",5],[10,"checked_sub","","",5],[10,"checked_mul","","",5],[10,"checked_div","","",5],[10,"div_rem","","",5],[10,"div_floor","","",5],[10,"mod_floor","","",5],[10,"div_mod_floor","","",5],[10,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`.",5],[10,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",5],[10,"divides","","Deprecated, use `is_multiple_of` instead.",5],[10,"is_multiple_of","","Returns `true` if the number is a multiple of `other`.",5],[10,"is_even","","Returns `true` if the number is divisible by `2`.",5],[10,"is_odd","","Returns `true` if the number is not divisible by `2`.",5],[10,"to_i64","","",5],[10,"to_u64","","",5],[10,"from_i64","","",5],[10,"from_u64","","",5],[10,"to_bigint","","",5],[10,"to_bigint","","",4],[10,"from_str_radix","","Creates and initializes a BigInt.",5],[10,"new","","Creates and initializes a BigInt.",5],[10,"from_biguint","","Creates and initializes a `BigInt`.",5],[10,"from_slice","","Creates and initializes a `BigInt`.",5],[10,"parse_bytes","","Creates and initializes a `BigInt`.",5],[10,"to_biguint","","Converts this `BigInt` into a `BigUint`, if it's not negative.",5],[10,"checked_add","","",5],[10,"checked_sub","","",5],[10,"checked_mul","","",5],[10,"checked_div","","",5],[0,"complex","num","Complex numbers."],[1,"Complex","num::complex","A complex number in Cartesian form."],[11,"re","","Real portion of the complex number",6],[11,"im","","Imaginary portion of the complex number",6],[4,"Complex32","",""],[4,"Complex64","",""],[10,"decode","","",6],[10,"encode","","",6],[10,"hash","","",6],[10,"clone","","",6],[10,"eq","","",6],[10,"ne","","",6],[10,"new","","Create a new Complex",6],[10,"norm_sqr","","Returns the square of the norm (since `T` doesn't necessarily\nhave a sqrt function), i.e. `re^2 + im^2`.",6],[10,"conj","","Returns the complex conjugate. i.e. `re - i im`",6],[10,"scale","","Multiplies `self` by the scalar `t`.",6],[10,"unscale","","Divides `self` by the scalar `t`.",6],[10,"inv","","Returns `1/self`",6],[10,"norm","","Calculate |self|",6],[10,"arg","","Calculate the principal Arg of self.",6],[10,"to_polar","","Convert to polar form (r, theta), such that `self = r * exp(i\n* theta)`",6],[10,"from_polar","","Convert a polar representation into a complex number.",6],[10,"add","","",6],[10,"sub","","",6],[10,"mul","","",6],[10,"div","","",6],[10,"neg","","",6],[10,"zero","","",6],[10,"is_zero","","",6],[10,"one","","",6],[10,"fmt","","",6],[0,"integer","num","Integer trait and functions."],[3,"div_rem","num::integer","Simultaneous integer division and modulus"],[3,"div_floor","","Floored integer division"],[3,"mod_floor","","Floored integer modulus"],[3,"div_mod_floor","","Simultaneous floored integer division and modulus"],[3,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`. The\nresult is always positive."],[3,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`."],[6,"Integer","",""],[9,"div_floor","","Floored integer division.",7],[9,"mod_floor","","Floored integer modulo, satisfying:",7],[9,"gcd","","Greatest Common Divisor (GCD).",7],[9,"lcm","","Lowest Common Multiple (LCM).",7],[9,"divides","","Deprecated, use `is_multiple_of` instead.",7],[9,"is_multiple_of","","Returns `true` if `other` is a multiple of `self`.",7],[9,"is_even","","Returns `true` if the number is even.",7],[9,"is_odd","","Returns `true` if the number is odd.",7],[10,"div_rem","","Simultaneous truncated integer division and modulus.\nReturns `(quotient, remainder)`.",7],[10,"div_mod_floor","","Simultaneous floored integer division and modulus.\nReturns `(quotient, remainder)`.",7],[0,"iter","num","External iterators for generic mathematics"],[1,"Range","num::iter","An iterator over the range [start, stop)"],[1,"RangeInclusive","","An iterator over the range [start, stop]"],[1,"RangeStep","","An iterator over the range [start, stop) by `step`. It handles overflow by stopping."],[1,"RangeStepInclusive","","An iterator over the range [start, stop] by `step`. It handles overflow by stopping."],[3,"range","","Returns an iterator over the given range [start, stop) (that is, starting\nat start (inclusive), and ending at stop (exclusive))."],[3,"range_inclusive","","Return an iterator over the range [start, stop]"],[3,"range_step","","Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping."],[3,"range_step_inclusive","","Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping."],[10,"clone","","",8],[10,"next","","",8],[10,"size_hint","","",8],[10,"next_back","","",8],[10,"clone","","",9],[10,"next","","",9],[10,"size_hint","","",9],[10,"next_back","","",9],[10,"clone","","",10],[10,"next","","",10],[10,"clone","","",11],[10,"next","","",11],[0,"traits","num","Numeric traits for generic mathematics"],[6,"Num","num::traits","The base trait for numeric types"],[6,"Zero","","Defines an additive identity element for `Self`."],[9,"zero","","Returns the additive identity element of `Self`, `0`.",12],[9,"is_zero","","Returns `true` if `self` is equal to the additive identity.",12],[6,"One","","Defines a multiplicative identity element for `Self`."],[9,"one","","Returns the multiplicative identity element of `Self`, `1`.",13],[6,"Signed","","Useful functions for signed numbers (i.e. numbers that can be negative)."],[9,"abs","","Computes the absolute value.",14],[9,"abs_sub","","The positive difference of two numbers.",14],[9,"signum","","Returns the sign of the number.",14],[9,"is_positive","","Returns true if the number is positive and false if the number is zero or negative.",14],[9,"is_negative","","Returns true if the number is negative and false if the number is zero or positive.",14],[6,"Unsigned","","A trait for values which cannot be negative"],[6,"Bounded","","Numbers which have upper and lower bounds"],[9,"min_value","","returns the smallest finite number this type can represent",15],[9,"max_value","","returns the largest finite number this type can represent",15],[6,"Saturating","","Saturating math operations"],[9,"saturating_add","","Saturating addition operator.\nReturns a+b, saturating at the numeric bounds instead of overflowing.",16],[9,"saturating_sub","","Saturating subtraction operator.\nReturns a-b, saturating at the numeric bounds instead of overflowing.",16],[6,"CheckedAdd","","Performs addition that returns `None` instead of wrapping around on overflow."],[9,"checked_add","","Adds two numbers, checking for overflow. If overflow happens, `None` is returned.",17],[6,"CheckedSub","","Performs subtraction that returns `None` instead of wrapping around on underflow."],[9,"checked_sub","","Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.",18],[6,"CheckedMul","","Performs multiplication that returns `None` instead of wrapping around on underflow or\noverflow."],[9,"checked_mul","","Multiplies two numbers, checking for underflow or overflow. If underflow or overflow\nhappens, `None` is returned.",19],[6,"CheckedDiv","","Performs division that returns `None` instead of panicking on division by zero and instead of\nwrapping around on underflow and overflow."],[9,"checked_div","","Divides two numbers, checking for underflow, overflow and division by zero. If any of that\nhappens, `None` is returned.",20],[0,"rational","num","Rational numbers"],[1,"Ratio","num::rational","Represents the ratio between 2 numbers."],[4,"Rational","","Alias for a `Ratio` of machine-sized integers."],[4,"Rational32","",""],[4,"Rational64","",""],[4,"BigRational","","Alias for arbitrary precision rationals."],[10,"decode","","",21],[10,"encode","","",21],[10,"hash","","",21],[10,"clone","","",21],[10,"from_integer","","Creates a ratio representing the integer `t`.",21],[10,"new_raw","","Creates a ratio without checking for `denom == 0` or reducing.",21],[10,"new","","Create a new Ratio. Fails if `denom == 0`.",21],[10,"to_integer","","Converts to an integer.",21],[10,"numer","","Gets an immutable reference to the numerator.",21],[10,"denom","","Gets an immutable reference to the denominator.",21],[10,"is_integer","","Returns true if the rational number is an integer (denominator is 1).",21],[10,"reduced","","Returns a `reduce`d copy of self.",21],[10,"recip","","Returns the reciprocal.",21],[10,"floor","","Rounds towards minus infinity.",21],[10,"ceil","","Rounds towards plus infinity.",21],[10,"round","","Rounds to the nearest integer. Rounds half-way cases away from zero.",21],[10,"trunc","","Rounds towards zero.",21],[10,"fract","","Returns the fractional part of a number.",21],[10,"from_float","","Converts a float into a rational number.",21],[10,"eq","","",21],[10,"ne","","",21],[10,"lt","","",21],[10,"gt","","",21],[10,"le","","",21],[10,"ge","","",21],[10,"partial_cmp","","",21],[10,"cmp","","",21],[10,"mul","","",21],[10,"div","","",21],[10,"add","","",21],[10,"sub","","",21],[10,"rem","","",21],[10,"neg","","",21],[10,"zero","","",21],[10,"is_zero","","",21],[10,"one","","",21],[10,"abs","","",21],[10,"abs_sub","","",21],[10,"signum","","",21],[10,"is_positive","","",21],[10,"is_negative","","",21],[10,"fmt","","Renders as `numer/denom`. If denom=1, renders as numer.",21],[10,"from_str","","Parses `numer/denom` or just `numer`.",21],[10,"from_str_radix","","Parses `numer/denom` where the numbers are in base `radix`.",21]],"paths":[[2,"Sign"],[6,"ToBigUint"],[6,"ToBigInt"],[6,"RandBigInt"],[1,"BigUint"],[1,"BigInt"],[1,"Complex"],[6,"Integer"],[1,"Range"],[1,"RangeInclusive"],[1,"RangeStep"],[1,"RangeStepInclusive"],[6,"Zero"],[6,"One"],[6,"Signed"],[6,"Bounded"],[6,"Saturating"],[6,"CheckedAdd"],[6,"CheckedSub"],[6,"CheckedMul"],[6,"CheckedDiv"],[1,"Ratio"]]};

initSearch(searchIndex);
